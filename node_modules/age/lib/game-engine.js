// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, GameEngine, HOMEDIR, IS_INSTRUMENTED, LIB_DIR, MemoryDataStore, Util, exports, fs, path,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require('path');

  fs = require('fs');

  HOMEDIR = path.join(__dirname, '..');

  IS_INSTRUMENTED = fs.existsSync(path.join(HOMEDIR, 'lib-cov'));

  LIB_DIR = IS_INSTRUMENTED ? path.join(HOMEDIR, 'lib-cov') : path.join(HOMEDIR, 'lib');

  MemoryDataStore = require(path.join(LIB_DIR, 'memory-data-store')).MemoryDataStore;

  Util = require(path.join(LIB_DIR, 'util')).Util;

  EventEmitter = require('events').EventEmitter;

  GameEngine = (function(_super) {
    __extends(GameEngine, _super);

    GameEngine.EET_ACHIEVED = 'achievement-achieved';

    GameEngine.EET_OCCURRED = 'event-occurred';

    function GameEngine(datastore, achievement_rules) {
      this.achievements_by_player = __bind(this.achievements_by_player, this);
      this._evaluate_achievement_rule = __bind(this._evaluate_achievement_rule, this);
      this._evaluate_single_achievement = __bind(this._evaluate_single_achievement, this);
      this.get_player_achievements = __bind(this.get_player_achievements, this);
      this.get_player_history = __bind(this.get_player_history, this);
      this.get_player = __bind(this.get_player, this);
      this.add_achievement_rule = __bind(this.add_achievement_rule, this);
      this.add_achievement = __bind(this.add_achievement, this);
      this.add_event = __bind(this.add_event, this);
      this.add_player = __bind(this.add_player, this);
      this.datastore = datastore != null ? datastore : new MemoryDataStore();
      this.achievement_rules = achievement_rules != null ? achievement_rules : [];
    }

    GameEngine.prototype.add_player = function(player, callback) {
      return this.datastore.record_player(player, callback);
    };

    GameEngine.prototype.add_event = function(player, event, callback) {
      var _this = this;
      return this.datastore.record_event(player, event, function(err) {
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          _this.emit(GameEngine.EET_OCCURRED, {
            player: player,
            event: event,
            engine: _this,
            type: GameEngine.EET_OCCURRED
          });
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    };

    GameEngine.prototype.add_achievement = function(player, achievement, callback) {
      var _this = this;
      return this.datastore.record_achievement(player, achievement, function(err) {
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          _this.emit(GameEngine.EET_ACHIEVED, {
            player: player,
            achievement: achievement,
            engine: _this,
            type: GameEngine.EET_ACHIEVED
          });
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    };

    GameEngine.prototype.add_achievement_rule = function(rule) {
      return this.achievement_rules.push(rule);
    };

    GameEngine.prototype.get_player = function(player, callback) {
      return this.datastore.get_player(player, callback);
    };

    GameEngine.prototype.get_player_history = function(player, callback) {
      var _this = this;
      return this.get_player(player, function(err, player) {
        var _ref;
        return typeof callback === "function" ? callback(err, (_ref = player != null ? player.history : void 0) != null ? _ref : []) : void 0;
      });
    };

    GameEngine.prototype.get_player_achievements = function(player, callback) {
      var _this = this;
      return this.get_player(player, function(err, player) {
        var action;
        action = function(rule, index, list, next) {
          return _this._evaluate_achievement_rule(player, rule, function(err) {
            if (err != null) {
              return typeof callback === "function" ? callback(err, player != null ? player.achievements : void 0) : void 0;
            } else {
              return next();
            }
          });
        };
        return Util.for_each_async(_this.achievement_rules, action, function() {
          return typeof callback === "function" ? callback(null, player != null ? player.achievements : void 0) : void 0;
        });
      });
    };

    GameEngine.prototype._evaluate_single_achievement = function(key, player, rule, callback) {
      var count,
        _this = this;
      if ((rule.multiplicity != null) && rule.multiplicity > 0) {
        count = Util.count(player.achievements, key, rule.multiplicity);
        if (count >= rule.multiplicity) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
      }
      return rule.predicate(key, this, player, function(err, achieved) {
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else if (achieved) {
          player.achievements.push(key);
          if ((rule.transient != null) && rule.transient) {
            return typeof callback === "function" ? callback() : void 0;
          } else {
            return _this.add_achievement(player, key, callback);
          }
        } else {
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    };

    GameEngine.prototype._evaluate_achievement_rule = function(player, rule, callback) {
      var keyfn,
        _this = this;
      if (typeof rule.key === 'function') {
        keyfn = rule.key;
      } else {
        keyfn = function(e, p, c) {
          return c(null, rule.key);
        };
      }
      return keyfn(this, player, function(err, keys) {
        var for_each;
        if (err != null) {
          if (typeof callback === "function") {
            callback(err);
          }
        } else if (keys == null) {
          if (typeof callback === "function") {
            callback();
          }
        } else {
          if (!(Array.isArray(keys))) {
            keys = [keys];
          }
          for_each = function(key, index, list, next) {
            return _this._evaluate_single_achievement(key, player, rule, function(err) {
              if (err != null) {
                return typeof callback === "function" ? callback(err) : void 0;
              } else {
                return next();
              }
            });
          };
          return Util.for_each_async(keys, for_each, callback);
        }
      });
    };

    GameEngine.prototype.achievements_by_player = function(callback) {
      var _this = this;
      if (this.datastore.enumerate_player_ids == null) {
        return typeof callback === "function" ? callback(new Error("Method not supported")) : void 0;
      } else {
        return this.datastore.enumerate_player_ids(function(err, players) {
          var for_each, map, when_done;
          map = {};
          for_each = function(id, index, list, next) {
            return _this.get_player_achievements({
              id: id
            }, function(err, achievements) {
              if (err != null) {
                return typeof callback === "function" ? callback(err) : void 0;
              } else {
                map[id] = achievements;
                return next();
              }
            });
          };
          when_done = function() {
            return typeof callback === "function" ? callback(null, map) : void 0;
          };
          return Util.for_each_async(players, for_each, when_done);
        });
      }
    };

    return GameEngine;

  })(EventEmitter);

  exports = exports != null ? exports : this;

  exports.GameEngine = GameEngine;

}).call(this);
